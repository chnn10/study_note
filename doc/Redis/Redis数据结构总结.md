BitMap

- 应用：如果我们要统计一个用户一个年的签到记录，签到是true，否则是false，如果有一亿个用户，那么需要的存储量是巨大的。
- 位图：这时候，如果使用的是BitMap，也是一个byte数组，只是用户每签到一次，只是用bitMap数组的一位就可以记录了，这样大大减少的内存的使用。

HyperLogLog

- 应用：PV，给每个网页一个独立的Redis计数，没来一个请求，这个数值就+1，在后缀上加上当天的日期，就可以统计每天的PV，很简单。
- 应用：UV，统计的是用户的访问量，每个用户每天访问多次也只能是一次，我们也可以使用set集合来实现，但是如果当一个页面的访问量巨大，而且有很多很多这样的页面，那么set集合是很浪费空间的。
- HyperLogLog：其实一个网页的UV其实也不需要特别准确，一个网页的访问量是103W还是102W，对我们来说其实差别不大，HyperLogLog统计可能会存在一点点误差，不过它依然是非常适合用于统计UV的一个数据结构。

- 原理：很难很难，不看了

BooleanFilter

概述

- 概述：布隆过滤器理解为一个不是很精确的set结构，布隆过滤器说某个值存在的时候，它可能是存在的，如果说它不存在，那肯定就是不存在。布隆过滤器对于已经见过的元素肯定不会误判，对于没有见过的可能会误判。
- 应用场景：推荐系统中，布隆过滤器可以精准地过滤掉已经看过的内容，那些没有看过的新内容，可能有一些误判，就是用户其实是没有看过的，布隆过滤器判断已经看过了，但是这一点其实是影响不算大的。

原理

- 组成：每隔布隆过滤器对应着Redis的数据结构就是一个巨大的位数组，和几个不一样的hash函数。
- 添加：向布隆过滤器添加一个key的时候，每隔hash函数都和key进行计算，然后每隔hash都会对应着这个key都有一个位置，然后在每一个位置上都置为1，完成add操作。
- 获取：首先是获取key和每一个hash函数对应着的位置，如果这些位置都是1，布隆过滤器就认为这个key是存在的，如果有0，布隆过滤器就觉得这个key是不存在的。
- 疑问：当然，每隔位置都是1，也不能代表这个key一定存在，也可能这个位置是其他key的存在导致的，这个也取决于hash函数的计算，这属于统计概率的范畴，至于这个概率怎么计算出来，这个太难了，没有继续往下深究。


sds

- 概述：sds是一个简单的动态字符串，底层就是封装了C语言的字符串，实现类型和Java的ArrayList类似，也是可以进行扩容的，字符串小于1M之前，每次采取加倍扩容，长度超过1M，每次只会扩容1M，当然一个sds最多不能超过512M。

hash

- 概述：hash他就是一个散列表嘛，然后它和HashMap原理也是很像的，只是它只有数组和链表，而且一个字典是有两个hashtable，为什么呢，主要使用rehash。它的rehash和HashMap的rehash也是不一样的。
- rehah
  - hash过程：字典有两个hash表的，没有发生rehash的时候只使用一个表，进行rehash的时候，就是将一个hash表的数据搬迁到另一个表中，但是它不是一次性进行rehash的，而是一步一步进行的。因为如果一个表中的数据很大，一次性进行rehash，其实是比较耗费性能的，所以采取step by step的方式。
  - 增删改查：rehash的过程中，如果是发生了新增的操作，直接在新表进行新增操作；如果是查询操作，首先是去旧的表查询，没有了才会去新表查。
  - 定期扫面：rehash没有采取一次性，就是将rehash的操作分散到每次的请求上。当然，如果是没请求一次就进行一次rehash操作，那什么时候才能rehash完哦，所以会有个定时扫描任务进行rehash，这样就可以缩短rehash的过程。






