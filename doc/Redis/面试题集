package cn.chnn10.testmyself;

/**
 * Redis持久化
 */
public class Redis {
    /**
     * Redis持久化
     * 	    Redis提供了哪几种持久化方式？
     * 	    RDB和AOF的优缺点
     * 	    Redis持久化的底层如何实现的？有什么优点缺点？
     *  	如何选择合适的持久化方式？
     *
     *  Redis集群
     *      说一下Redis的主从复制
     *      讲一下复制的过程
     *      说一下Redis哨兵
     *      哨兵工作原理
     *
     *      Redis 集群方案应该怎么做？都有哪些方案？
     *      Redis 集群方案什么情况下会导致整个集群不可用？
     *      Redis 集群的主从复制模型是怎样的？
     *      Redis 集群会有写操作丢失吗？为什么？
     *      Redis 集群之间是如何复制的？
     *      Redis 集群最大节点个数是多少？
     *      Redis 集群如何选择数据库？
     *
     *  Redis缓存
     *      什么是缓存穿透？怎么解决？如何避免？
     *      什么是缓存雪崩？怎么解决？何如避免？
     *      什么是缓存击穿？怎么解决？如何避免？
     *      如何保证缓存与数据库双写时的数据一致性?
     *
     *  Redis事务
     *      怎么理解 Redis 事务？
     *      Redis事务的三个阶段
     *      说一下Redis的WATCH机制
     *
     *  Redis内存优化
     *      Redis 有哪几种数据淘汰策略？
     *      Redis 如何做内存优化？
     *      Redis 回收进程如何工作的？
     *      redis 过期策略都有哪些？LRU 算法知道吗？
     *      Reids三种不同删除策略
     *      定时删除策略
     *      定期删除策略
     *      惰性删除策略
     *
     *  Redis锁
     *      什么是分布式锁
     *      分布式锁具备什么条件
     *      分布式锁的实现的实现方式
     *      加锁机制
     *      锁互斥机制
     *      使用 redis 如何设计分布式锁？说一下实现思路？使用 zk 可以吗？如何实现？这两种有什么区别？
     *
     *  Redis数据类型
     *      Redis的数据类型，以及每种数据类型的使用场景
     *      Redis 当中有哪些数据结构
     *
     *  Redis概念
     *      什么是 Redis？简述它的优缺点？
     *      Redis 与 memcached 相比有哪些优势？
     *      Redis 有哪些适合的场景？
     *      Redis 为什么这么快（说一下多线程，为什么使用多线程，说一下多路服用）
     *
     *  Redis管道
     *      Redis 中的管道有什么用？
     *
     *  Redis订阅模式
     *
     *
     *
     * ---------------------------------------------------Redis基本概念--------------------------------------------------
     * 1：Redis为什么这么快
     * Redis是一个内存数据结构，它得操作都是在内存中的，所以速度是很快的。
     * Redis的优秀的数据结构，底层的数据结构在性能方面做的比较好。比如string的内存预分配、hash的渐进式rehash，跳跃表跳跃表这些都是很考虑到性能问题的。
     * Redis在处理网络的请求是单线程的，避免线程切换的开销.
     * 采用了IO多路复用提高了IO的利用率，所以Redis是比较快的。
     *
     *
     * 2：Redis 与 Memcached 相比有哪些优势？
     * Memcached只支持string一种数据结构，而Redis有更丰富的数据结构。
     * Memcached没有持久化的功能，Redis是支持持久化的。
     *
     *
     * 3：Redis的线程模型（代办）操作系统中断 ---> 操作系统用户内核态 ---> 操作系统MMP ---> 操作系统DMA ---> 操作系统零拷贝 ---> 阻塞、非阻塞、同步、一步 ---> I/O多路复用
     *
     *
     *  ---------------------------------------------------------持久化--------------------------------------------------
     * 	1：Redis提供了哪几种持久化方式？（2022-6-13 第一次）
     * 	我们知道Redis事运行在内存中的数据库，它的数据是保存在内存中的，当Redis宕机或者断电的时候，这些数据就会丢失。
     * 	为了防止数据丢失，Redis提供了持久化的机制，Redis持久化的方式有RDB和AOF。
     * 	RDB就是内存快照嘛，就是在某个时间点保存Redis数据库所有的数据到磁盘中，当Redis服务重启的时候，通过读取RDB文件来恢复数据。
     * 	AOF就是服务端接收到写请求之后，会将这个命令追加到aof文件中，然后再保存到磁盘，Redis服务重启时，通过重新执行AOF文件的命令来恢复数据。
     * 	这就是Redis的两种持久化方式。
     *
     *
     * 	2：RDB和AOF的优缺点（2022-6-13 第一次）
     * 	因为RDB文件可以由子进程来实现的，生产RDB文件并不会影响主服务处理客户端的请求。当服务重启的时候，直接读取RDB文件就可以恢复数据，所有RDB的性能比较号，恢复数据比较快。
     * 	但是RDB容易丢失数据，发生断电的时候，就会丢失上一次快照到断电这个时间段的数据。其实丢失的数据也取决于执行快照的执行时间，间隔时间越长数据就会丢失越多。但是如果间隔时间太短也不行，虽然子进程生产RDB文件并不会阻塞
     * 	主进程，但是fork操作是会阻塞主进程的，频繁地fork子进程是会影响到Redis服务的性能的，所有也不行太频繁。这就是RDB的缺点。
     *
     * 	AOF的优点就是安全行比较高，数据丢失比较少，缺点就是性能方面不是很高，重启服务时通过执行AOF文件的的命令来恢复数据的，因此AOF恢复数据是比较慢的。
     * 	我们知道服务端执行完写命令之后会将写命令保存到磁盘中，断电或宕机的时候会丢失这些命令，但是这些命令比较少的，所以AOF的安全性是比较高的。
     *
     *
     * 	3：如何让选择合适的持久化方式（2022-6-13 第一次）
     * 	如何选择合适的持久化的方式，取决于我们的业务，如果我们更多考虑的是性能，就可以使用RDB，如果我们考虑更多的是数据的安全，那么就是用AOF。
     * 	当然也有一个mix的方式，混合是使用AOF和RDB，就是隔一段时间使用RDB，在这段时间的期间使用AOF，这样可以中和性能和安全的问题。
     *
     *
     * 	4：Redis持久化的底层实现（2022-6-13 第一次）
     * 	持久化有两种实现方式嘛，分别是RDB和AOF。
     * 	RDB实现是这样的，我们中执行了SAVE或者BGSAVE，都可是实现RDB。我们执行SAVE命令时，主进程会自己去生产RDB文件，期间不能处理客户端的请求，知道完成RDB的生产才可以继续请求命令。
     * 	当我们执行BGSAVE命令时，主进程会fork一个子进程，由子进程去执行快照去生产RDB文件，然后主进程继续去处理客户端的请求。当子进程创建完RDB文件之后会向主进程发送一个异步通知，主进程再做处理。
     * 	这就是RDB的底层实现。
     *
     * 	我们可以在配置文件中设置 appendsync yes来开启AOF功能。
     * 	当AOF功能打开时，服务端执行完写命令之后，就会讲命令放到缓冲区中，然后再从缓冲区刷回到磁盘中。
     * 	怎么讲缓存区的命令数据刷回磁盘，Redis也提供了配置选项。分别是appendsync always no everysec
     * 	如果时always，表示的是没执行一条命令就是刷回磁盘，这样做的安全性是比较高的，但是性能不是很好。
     * 	如果是noi，表示的是执行完命令之后放到缓存区，至于什么时候讲缓存区的数据刷回磁盘，取决于操作系统，这方式数据安全性不高但是性能比较好。
     * 	如果是evrysec，表示的是每隔一秒钟，就会讲缓存区的数据刷回到磁盘中，这样做是一个折中方法，中和了性能和数据的安全性。
     * 	这就是我对Redis持久化底层实现的理解。
     *
     *
     *
     * 	---------------------------------------------------------缓存--------------------------------------------------
     * 	1：什么是缓存穿透？怎么解决？如何避免？
     * 	缓存穿透就是用户的请求访问的数据在缓存中没有，在数据库层也没有，当有大量这样的请求时候，肯定会给数据库层造成很大的压力，有可能是恶意的攻击。
     * 	可以使用布隆器判断数据是否存放，对于不存在的数据就不访问数据库了，这样可以减少数据库的压力。
     * 	过滤器的原理（代办）
     *
     *
     *  2：什么是缓存雪崩？怎么解决？何如避免？
     *  我们引入Redis做缓存的时候，用户的请求首先回去缓存中获取，如果没有获取到，才会到数据库获取数据。Redis的缓存雪崩就是大量的用户请求都没能从缓存中获取数据，然后都请求到数据库，这会给数据库带来很大的压力。
     *  造成缓存雪崩的主要有大量的缓存在同一个时间失效，第二个就是Redis宕机了。
     *  怎么防止缓存雪崩呢，第一个就是随机设置缓存的过期时间，这样可以避免大量的缓存同一时间失效。还有就是搭建高可用的Redis集群，一个Redis宕机了，立马有其它的Redis提供服务。
     *
     *
     *  3：什么是缓存击穿？怎么解决？如何避免？
     *  缓存击穿指的是数据在数据库存在，但是在缓存中不存在，就是在缓存中过期了，当大量的请求都需要访问这个数据，就会给数据库造成很大的压力。为了避免这种情况，我们可以对热点的数据设置永不过去。
     *  那么击穿和雪崩有什么区别呢，雪崩指的是大范围的缓存失效的场景，击穿指的是某个热点数据失效的场景。
     *
     *  4：缓存一致性（代办）----------> 自己找答案
     *
     *
     *
     * ---------------------------------------------------------事务--------------------------------------------------
     *  1：说一说Redis的事务
     *  Redis事务允许一次可以执行多条命令，MULTI命令就是Redis事务的开始，然后Redis会将命令放进一个队列中，当遇到EXEC命令时，Redis就会顺序执行队列中的命令。
     *  当然，Redis事务是没有回滚的，在执行命令的过程中，如果有一条命令执行失败了，剩下的命令会继续被执行。
     *  执行的过程中不会被中断，只有执行完了才可以继续请求其他客户端的请求。
     *  这就是我对Redis事务的理解。
     *
     *
     *  2：说一下Redis的WATCH机制（官网答案）
     *
     *
     *
     * ---------------------------------------------------------主从复制-----------------------------------------------
     * 1：说一下Redis的主从复制
     * 我们知道Redis持久化机制就是确保Redis宕机或者断电时，重启时可以恢复Redis的数据。但是当Redis宕机了，就无法提供服务了，为了确保Redis的服务提供，就需要有多个Redis实例。
     * 当一个Redis挂掉之后，还有其他的实例可以提供服务。
     * Redis的主从关系是这样的，就是主节点提供读写服务、从节点提供读服务，那么两个Redis实例是怎么变成主从关系的呢。一个Redis实例执行了repOf 另一台Redis的ip 端口，执行命令的Redis就变成了一个从节点。
     * 主节点收到命令之后，就会fork子进程去生产一个RDB文件，生产RDB文件之后，就发给从节点，这样两台实例的数据就一致了，这就是Redis主从复制的基本情况。
     *
     *
     * 2：说一下Redis复制的过程（代办）-----> 参考官网怎么回答的
     *      1：当从节点要复制主节点的数据，从节点会发送一个PSYNC命令给主节点，同时会有一个复制ID和偏移量，如果复制的ID和上次的是一样的，主节点会根据根据偏移量后面新增的数据发给从节点。
     *
     *      2：这个怎么理解偏移量呢，比如文件A复制文件B的数据，数据一致的情况，文件最新的数据在100行，文件B也一样。那么文件B又增加了数据写到了150行，文件A在复制的时候，
     *          偏移量就相当于100嘛，这样文件B就将101行到150行的数据发给文件A。
     *
     *      3：这个复制ID怎么理解呢，其实这个复制ID就是主节点的一个标识，因为主节点宕机下线了，会有从节点接替成为新的主节点，这时候其他从节点执行复制操作，这时候复制ID就不一样了。
     *
     *      当从服务器对主服务器进行初次复制时，主服务器将会将自己的运行ID传送给从服务器，而从服务器会将这个运行ID保存起来
     *      当从服务器断线并重新连接上主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：
     *      4：如果复制的ID不一样，或者是从节点第一次执行复制操作，主节点收到命令之后，会fork一个子进程去生产RDB文件。接着会将新接收到的命令写到缓存区中，当RDB文件生成之后，就发给从节点，接着
     *          主节点还会将缓冲区中的数据发给从节点。这样就可以主从就可以达到一致性了。
     *          这就是我对主从复制实现的理解。
     *
     *
     *
     *
     * ---------------------------------------------------------哨兵--------------------------------------------------
     * 1：说一下Redis哨兵
     * Redis一般都是有多个实例同时工作的，主节点负责读写请求，从节点负责读请求。如果有一个从节点挂掉了，还有主节点和其他的从节点可以提供服务。
     * 如果主节点挂掉了，从节点可以提供读请求，但是是无法提供写请求的，这肯定是不行的。那么办呢，哨兵就出来了。
     * 哨兵就是一个特殊的Redis实例，当哨兵监控到主节点挂掉了，就会将一个从节点代替挂掉的主节点成为新的主节点，然后新的和其他的从节点形成一个新的主从关系，这样就可以继续正常地提供服务。
     *
     *
     * 2：说一下哨兵的工作原理（代办）监控下线的主节点 ---> 官网参考答案
     *      1：当哨兵启动的时候，他会定时地给主节点发送PING命令，如果在规定的时间没有响应，哨兵就会主管地认为这个主节点已经下线，为什么说是主观认为呢？没有响应也可能是网络延迟的原因，因此这不能仅仅用一个哨兵来决定的。
     *      哨兵一般都是集群的，而且哨兵的个数是奇数。当一个哨兵有监控到主观下线的主节点之后，就会通知其他的哨兵也一起判断这个主节点是否下线。当有超过半数的哨兵都认为这个主节点是下线的了，这时候，这个主节点就变成了客观
     *      下线，这时候，哨兵就会选择从节点成为新的主节点。
     *
     * 2：那应该选择哪一个从节点呢？
     *      从节点的配置文件中是可以设置一个slave-priority的优先级的，优先级高的会设置成新的主节点，如果优先级是一样的，就可以那个节点的数据更完整。哨兵会给这个从节点发送一个slave no one，这样它就可以成为新的主节点。
     *
     * 3：通知
     *      选出新的主节点之后，哨兵会通知其他的从节点，让它们执行slave 新主节点的ip 端口，这样就可以形成可一个新的主从节点。这就是哨兵的一个工作原理。
     *
     */






    /**
     * 复制偏移量
     * 执行复制的双方,主服务器和从服务器都会维护一个复制偏移量,主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加N。从服务器每次收到主服务器传播来的N个字节的数据的时，就将自己的复制偏移量的值加N。
     * 如果主从服务器处于一致状态，那么从服务器两者的偏移量总是相
     * 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态
     * 既然知道了主从服务器是否处于一致状态，那么断线重新连接是该完整重同步还是部分重同步？如果部分重同步，主服务器又如何补偿从服务器丢失的那部分数据呢？
     *
     * 当从服务器重新连接上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个偏移量来决定对从服务器执行何种同步操作：
     *
     * 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主从服务器将对从服务器执行部分重同步操作
     * 如果offset偏移量之后的部分数据已经不存在于复制积压缓冲区（部分重同步就无法保证主从数据一致性），那么主服务器将对
     * 从服务器执行完整重同步操作
     * 注：Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，或者有时候从服务器断线后很久常能连上，PSYNC命令的部分重同步功能可能不能正常发挥其功能，可以考虑根据实际需求调整复制积压缓冲区大小
     *
     * 服务器运行ID
     *      每个Redis服务器，不论主服务器还是从服务器，都会有自己的运行ID。运行ID实在服务器启动的时候自动生成，由40个随机的十六进制字符组成
     *      当从服务器对主服务器进行初次复制时，主服务器将会将自己的运行ID传送给从服务器，而从服务器会将这个运行ID保存起来
     *      当从服务器断线并重新连接上主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：
     *      如果从服务器保存的运行ID与当前连接的ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。
     *      如果从服务器保存的运行ID与当前连接的主服务器运行ID并不相同，那么说明从服务器断线之前复制的主服务器不是当前连接，主服务器将对从服务器执行完整重同步
     *
     *
     *
     *
     *
     * -----------------Redis-------------------
     * Redis 复制的工作原理
     * 每个 Redis 主服务器都有一个复制 ID：它是一个大的伪随机字符串，用于标记数据集的给定故事。每个主服务器还采用一个偏移量，
     * 该偏移量随着它生成的要发送到副本的复制流的每个字节而增加，以使用修改数据集的新更改来更新副本的状态。即使没有实际连接副本，复制偏移也会增加，因此基本上每个给定的对：
     * Replication ID, offset
     * 识别主数据集的准确版本。
     *
     * 部分的：
     *      当副本连接到主服务器时，它们使用该PSYNC命令发送它们的旧主服务器复制 ID 和到目前为止它们处理的偏移量。这样，master 可以只发送所需的增量部分。
     *      但是，如果主缓冲区中没有足够的积压，或者如果副本引用不再已知的历史记录（复制 ID），则会发生完全重新同步：在这种情况下，副本将获得数据集的完整副本， 从头开始。
     *
     * 这是完全同步的详细工作方式：
     *      master 启动后台保存过程以生成 RDB 文件。同时它开始缓冲从客户端接收到的所有新的写命令。后台保存完成后，master将数据库文件传输到replica，replica将其保存在磁盘上，然后加载到内存中。
     *      然后主服务器会将所有缓冲的命令发送到副本。这是作为命令流完成的，并且与 Redis 协议本身的格式相同。
     *      您可以通过 telnet 自己尝试。在服务器执行某些工作时连接到 Redis 端口并发出SYNC命令。您将看到批量传输，然后主服务器收到的每个命令都将在 telnet 会话中重新发出。
     *      实际上SYNC是新的 Redis 实例不再使用的旧协议，但仍然存在向后兼容：它不允许部分重新同步，所以现在PSYNC使用。
     *      如前所述，当主从链路由于某种原因断开时，副本能够自动重新连接。如果 master 收到多个并发的副本同步请求，它会执行单个后台保存以服务所有这些请求。
     *
     */
}
