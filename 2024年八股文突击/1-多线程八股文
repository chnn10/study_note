所有的面试题
    谈谈进程和线程的区别
    谈谈创建线程的方式
    谈谈线程的状态
    谈谈wait和sleep的区别
    谈谈runnable和callable的区别



谈谈进程和线程的区别
    我们知道程序只是存放在磁盘中的指令和数据，我们要运行一个程序，就要讲它搬到内存中，它分配对应的一些资源，然后执行这个main方法，这样程序就运行起来了。
    正在运行的程序就是进程嘛，进程是一个动态的概念，进程也是资源分配的基本单元，一般包括堆栈内存和寄存器的这些资源嘛。
    线程只是进程的一个执行路径，一个进程可以多个线程同时执行的，线程是共享进程的资源的，线程是CPU调度的基本单位嘛。这就是我对进程和线程的一个理解。



谈谈Java创建线程的方式
    在Java中一共有三种创建线程的方式，分别是继承Thread类、实现Runnable接口和实现Callable接口。
    继承Thread类的方式就是新建一个类，然后继承Thread类，然后重写run方法，创建这个类的实例，调用这个实例的start方法就可以创建一个新的线程了。
    实现Runnable接口，就是新建一个类，然后实现Runnable接口，实现run方法，然后将这个类对象作为构造参数，去实例化Thread类，最后调用Thread类的start来创建一个新的线程。
    
    实现Runnable接口，新建一个类，去实现Callable的call方法，然后将这个类对象作为构造参数去新建一个FutureTask的对象，再将这个FutureTask的对象作为构造函数去新建一个Thread类，然后调用start方法来启动一个线程，
    这个Callable通过FutureTask的对象的get方法来返回线程的执行结果。
    这就是我对Java创建线程的理解。



谈谈run和start的区别
    start是Thread中创建一个新线程的方法，当一个线程执行start方法的时候，就会创建一个新的线程，然后这个新的线程就会去执行当前线程的run方法的代码。
    当执行的只是run方法的时候，并不会创建一个新的线程，而是由当前线程去执行run方法的代码，和执行一个普通方法是一样的。这就是我对run和start的一个理解。


谈谈线程的状态
    线程的状态主要运行、就绪和阻塞，但我们创建了一个新的线程并且给它分配资源，这时候这个线程是处于就绪的状态的，它获得了CPU的调度之后，就可以开始运行，这时候就处于运行的状态。
    在运行的线程如果遇到了IO事件，就让出CPU并处于阻塞的状态，当IO事件完成之后，线程就会从阻塞的状态回到就绪的状态，重新获取CPU才可以运行。
    当线程执行完了代码，这个线程的生命周期就会结束，处于终止的状态，这就是我对线程状态的理解。



谈谈wait和sleep的区别
    wait是Object类的一个方法，wait一般都是和synchronized和notify一起使用的，要执行wait方法的线程必须要获取到锁。
    当线程执行了wait之后，就会处于阻塞的状态，并且释放锁，它会一直阻塞住，直到有其他线程调用了这个对象的notify方法将它唤醒，它要重新获取到锁才可以执行。
    sleep是Thread类的一个静态方法，当一个线程调用了sleep方法之后，就会处于休眠的状态，当休眠的时间过之后，线程就可以恢复执行，在休眠的期间线程是不会释放锁的。





















谈谈JMM和volatile的理解
    JMM是Java内存模型，它是一组规范，它规范Java程序操作变量的方式。JVM将计算机中的内存、缓存和寄存器抽象成主内存和工作内存。
    JMM规定了Java中的变量都是存放在主内存的，主内存是线程共享的，然后每个线程都有自己的工作内存，线程不能直接操作主内存的，只能在自己的工作内存进行读写操作，线程之间互不干扰。
    线程要对操作一个变量，首先要到主内存那里拷贝到自己的工作内存中，操作完成之后，再将变量写回到主内存中。








































    
































