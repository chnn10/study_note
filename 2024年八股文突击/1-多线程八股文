所有的面试题
    谈谈进程和线程的区别
    谈谈创建线程的方式
    谈谈线程的状态
    谈谈wait和sleep的区别
    谈谈runnable和callable的区别
    谈谈JMM和volatile的理解   ---> 未完成
    谈谈你对synchronized的理解
    谈谈synchronized的锁升级的理解
    谈谈你对CAS的理解
    谈谈你对JMM的理解
    谈谈你对ThreadLocal的理解



谈谈进程和线程的区别
    我们知道程序只是存放在磁盘中的指令和数据，我们要运行一个程序，就要讲它搬到内存中，它分配对应的一些资源，然后执行这个main方法，这样程序就运行起来了。
    正在运行的程序就是进程嘛，进程是一个动态的概念，进程也是资源分配的基本单元，一般包括堆栈内存和寄存器的这些资源嘛。
    线程只是进程的一个执行路径，一个进程可以多个线程同时执行的，线程是共享进程的资源的，线程是CPU调度的基本单位嘛。这就是我对进程和线程的一个理解。



谈谈Java创建线程的方式
    在Java中一共有三种创建线程的方式，分别是继承Thread类、实现Runnable接口和实现Callable接口。
    继承Thread类的方式就是新建一个类，然后继承Thread类，然后重写run方法，创建这个类的实例，调用这个实例的start方法就可以创建一个新的线程了。
    实现Runnable接口，就是新建一个类，然后实现Runnable接口，实现run方法，然后将这个类对象作为构造参数，去实例化Thread类，最后调用Thread类的start来创建一个新的线程。
    
    实现Runnable接口，新建一个类，去实现Callable的call方法，然后将这个类对象作为构造参数去新建一个FutureTask的对象，再将这个FutureTask的对象作为构造函数去新建一个Thread类，然后调用start方法来启动一个线程，
    这个Callable通过FutureTask的对象的get方法来返回线程的执行结果。
    这就是我对Java创建线程的理解。



谈谈run和start的区别
    start是Thread中创建一个新线程的方法，当一个线程执行start方法的时候，就会创建一个新的线程，然后这个新的线程就会去执行当前线程的run方法的代码。
    当执行的只是run方法的时候，并不会创建一个新的线程，而是由当前线程去执行run方法的代码，和执行一个普通方法是一样的。这就是我对run和start的一个理解。


谈谈线程的状态
    线程的状态主要运行、就绪和阻塞，但我们创建了一个新的线程并且给它分配资源，这时候这个线程是处于就绪的状态的，它获得了CPU的调度之后，就可以开始运行，这时候就处于运行的状态。
    在运行的线程如果遇到了IO事件，就让出CPU并处于阻塞的状态，当IO事件完成之后，线程就会从阻塞的状态回到就绪的状态，重新获取CPU才可以运行。
    当线程执行完了代码，这个线程的生命周期就会结束，处于终止的状态，这就是我对线程状态的理解。



谈谈wait和sleep的区别
    wait是Object类的一个方法，wait一般都是和synchronized和notify一起使用的，要执行wait方法的线程必须要获取到锁。
    当线程执行了wait之后，就会处于阻塞的状态，并且释放锁，它会一直阻塞住，直到有其他线程调用了这个对象的notify方法将它唤醒，它要重新获取到锁才可以执行。
    sleep是Thread类的一个静态方法，当一个线程调用了sleep方法之后，就会处于休眠的状态，当休眠的时间过之后，线程就可以恢复执行，在休眠的期间线程是不会释放锁的。


谈谈JMM和volatile的理解
    JMM是Java内存模型，它是一组规范，它规范Java程序操作变量的方式。JVM将计算机中的内存、缓存和寄存器抽象成主内存和工作内存。
    JMM规定了Java中的变量都是存放在主内存的，主内存是线程共享的，然后每个线程都有自己的工作内存，线程不能直接操作主内存的，只能在自己的工作内存进行读写操作，线程之间互不干扰。
    线程要对操作一个变量，首先要到主内存那里拷贝到自己的工作内存中，操作完成之后，再将变量写回到主内存中。


谈谈你对synchronized的理解   ---> 未完成
    synchronized是Java实现线程同步的一个关键字，它是线程安全的，同一个时刻只允许一个线程获取锁，其他线程获取锁失败就会阻塞起来，要等到当前线程释放锁才能继续竞争锁，只有获取锁成功的线程才能执行synchronzied修饰的代码。
    synchronized可以用来修饰代码块或者方法，它底层是由JVM实现的。



谈谈synchronized的锁升级的理解
    在JDK1.6之前，线程访问synchronzied修饰的方法都需要进行加锁操作，因为synchronzied是由JVM层面实现的，加锁操作会涉及到进程上下文切换，加锁成本比较高，是比较消耗性能的，所以它是一个重量级的锁。
    在JDK1.6之后，对synchronized进行了锁优化，主要是引入了偏向锁和轻量级锁，在synchronized的使用的过程中，会从无锁，到偏向锁，再到轻量级锁，最后到重量级锁。这些锁的标识就记录在这个锁的对象头那里。

    无锁相当于，当前对象的锁还没有线程获取到。偏向锁表示的是锁偏向于某个线程，当第一个线程获取到这个锁的时候，这个锁的对象头那里就会记录偏向锁的标识位，和这个线程的线程ID，当这个线程再次访问锁的时候，就可以直接进入方法了。
    偏向锁主要是用于优化同一个线程多次访问锁的场景。现在就是第一个线程已经获取到了锁，这个锁是偏向于第一个线程的，现在有第二个线程来获取锁，第二个线程就会使用CAS的方式去获取锁，如果第一个线程刚好释放了锁，那么第二个线程就会获取锁成功，目前的锁还是偏向锁。
    如果第一个线程还没有释放锁，那么第二个线程就失败嘛，这个时候就表示有多个线程在竞争锁了，此时偏向锁就会升级为轻量级锁。
    这个时候没有获取到锁的线程就会进行自旋操作尝试去获取锁，当自旋的次数超过一定的值之后，就会升级为重量级锁，然后线程就会阻塞起来。这就是我对synchronzied的理解。
    








































    
































