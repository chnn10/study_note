谈谈线程和进程的区别
程序是存在磁盘的指令和数据，我们要运行一个程序，就需要将它加载到内存然后执行main方法才可以执行。进程就是正在运行中的程序，进程它是一个动态的，它有自己的生命周期和进程状态，它也是资源分配的基本单位，主要包括了一个堆栈、寄存器和IO的一些资源。线程就是进程的一个执行路径，一个进程可以有多个线程，线程是CPU调度的基本单位。比如说我们在Java中执行一个main函数，就是启动了一个JVM进程，然后这个main函数就是JVM进程的主线程，线程的上下文切换是更轻量的，这就是我对进程和线程的理解。
谈谈Java是如何创建线程的
Java中有四种创建线程的方式，分别是继承Thread类、实现Runnable接口、实现Callable接口、还有就是使用线程池。
继承Thread类就是新建一个类，然后继承Thread类，然后重写run方法，最后new一个实例，调用这个实例的start方法，这样就可以新建一个线程。
实现Runnable接口的方式，就是新建一个类实现Runnable接口，然后实现run方法，然后将这个类的实例作为构造参数去new一个Thread实例，然后调用Thread实例的start方法。
实现Callable接口的方式，就是新建一个类去实现Callable接口，然后实现call方法，然后将这个类的实例作为构造参数去new一个FutureTask实例，再将这个FutureTask实例作为构造参数去new一个Thread类实例，最后去调用这个实例的start方法，Callable它是有返回值的，可以通过FutereTask的get方法获取到它的返回值。
项目中一般都是使用线程池来创建线程的，比如使用哪个Excutor的submit方法来创建线程。Java中创建线程的方式有好几种，这些方式最终都是需要通过Thread类中的那个start方法，start方法去调用操作系统层面的系统调用去创建一个新的线程，最终实现多线程的执行。这就是我对Java创建线程的理解。
谈谈线程的状态
当操作系统创建了一个新的线程，然后给它分配了基本的资源，这些资源主要是一些堆栈的信息，这个线程就处于一个就绪的状态，当它获取到CPU的调度，它就可以执行了，这时候就是执行的状态，在执行的过程中，如果遇到了一些IO事件，就会让出CPU然后一直处于阻塞的状态，当IO事件完成之后，就可以从阻塞的状态变成就绪的状态，重新获得CPU调度然后又可以重新执行。在线程执行的过程，如果时间片用完了，就会让出CPU然后处于就绪的状态。在线程的执行过程中，可能会遇到很多次的IO事件和时间片用完的情况，这些都会发生线程状态的转换，当线程执行完它的指令，线程的生命周期就结束了，然后处于终结的状态。这就是我对线程生命周期的理解。
谈谈wait和sleep的区别
wait方法是Object类的一个实例方案，而sleep方法则是Thread类的一个静态方法。只有获取到锁的线程才能调用wait方法，当一个线程调用了wait方法之后，它就会释放锁，然后就会一直处于阻塞的状态，直到有线程调用这个对象的notify方法将它唤醒，唤醒之后的线程需要重新竞争锁才能继续执行。这个wait方法一般都是需要和synchronized和notify方法一起使用的。而当一个线程调用了sleep方法之后，就会处于休眠的状态，当休眠的时间到了，就可以重新恢复执行，在休眠的期间它是不会释放锁的。这就是我对wait和sleep方法的理解。
谈谈synchronized的底层原理
synchronized是Java实现线程同步的一个关键字，它是线程安全的，同一个时刻只允许一个线程获取锁，其他线程获取锁失败就会阻塞起来，要等到当前线程释放锁才能继续竞争锁，只有获取锁成功的线程才能执行synchronzied修饰的代码。
synchronized可以用来修饰代码块或者方法，它底层是由JVM实现的。
● todo 底层实现
谈谈synchronized锁升级
在JDK1.6之前，线程访问synchronzied修饰的方法都需要进行加锁操作，因为synchronzied是由JVM层面实现的，加锁操作会涉及到进程上下文切换，加锁成本比较高，是比较消耗性能的，所以它是一个重量级的锁。
在JDK1.6之后，对synchronized进行了锁优化，主要是引入了偏向锁和轻量级锁，在synchronized的使用的过程中，会从无锁，到偏向锁，再到轻量级锁，最后到重量级锁。这些锁的标识就记录在这个锁的对象头那里。
无锁相当于，当前对象的锁还没有线程获取到。偏向锁表示的是锁偏向于某个线程，当第一个线程获取到这个锁的时候，这个锁的对象头那里就会记录偏向锁的标识位，和这个线程的线程ID，当这个线程再次访问锁的时候，就可以直接进入方法了，偏向锁主要是用于优化同一个线程多次访问锁的场景。
现在就是第一个线程已经获取到了锁，这个锁是偏向于第一个线程的，现在有第二个线程来获取锁，第二个线程就会使用CAS的方式去获取锁，如果第一个线程刚好释放了锁，那么第二个线程就会获取锁成功，目前的锁还是偏向锁。如果第一个线程还没有释放锁，那么第二个线程就失败嘛，这个时候就表示有多个线程在竞争锁了，此时偏向锁就会升级为轻量级锁。
这个时候没有获取到锁的线程就会进行自旋操作尝试去获取锁，当自旋的次数超过一定的值之后，就会升级为重量级锁，然后线程就会阻塞起来。这就是我对synchronzied的理解。
谈谈你对CAS的理解
CAS是比较替换的意思，它是一个轻量级的锁。它在修改一个变量的时候，先获取到内存中这个变量的值，这个值就是它期待的值。在进行写操作的时候，只有当它操作的这个变量的值是它期待的值，它才会进行修改，如果不是这表示这个变量已经被其他线程修改了，就会放弃这一次的修改，然后自旋重试，直到成功为止。说它是轻量级锁的原因是当线程进行CAS失败的时候，线程并不会阻塞起来，不会发生进程上下文切换，而是进行自旋操作重试，所以它的性能会比synchronized好一点。
CAS会有什么问题
当然CAS也可能会有ABA的问题，比如一个线程要对一个值为1的变量进行写操作的时候，这个变量已经被其他线程修改了其他的值，然后又修改会为1，这个时候其实这个变量已经发生了变量，但是当前线程在判断的时候，还是会认为它就是自己期待的值，所以就进行写操作，这时候可能出现问题了。要解决这个问题，可以引入一个版本号，就是每次获取期待的值的时候，还需要加上一个版本号，在比较的时候，只有版本号和期待的值都相同了才会进行修改，这样就可以避免了ABA的问题了。

















