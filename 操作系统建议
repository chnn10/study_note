题目：如何从零开始写一个操作系统？




汇编不重要，但是要有一定计算机组成的基础，并对一个现代 kernel 的结构有大体的认识，至少大致上理解虚拟内存和文件系统有哪些东西。不要看 《the orange's》和《三十天编操作系统》，面太小，代码质量不高，就别拿 DOS 当操作系统了。个人比较推荐《莱昂氏 UNIX 源码分析》（已绝版，可淘宝打印）、《linux 0.11 内核详解/剖析》 ，写代码之前至少先都啃一遍。教程的话推荐 《bran's kernel development tutorial》和 osdev 上的一些资料。顺着它们搭开发环境，出一个简单的 bootlaoder，可以编译 C 代码即可。然后拿大把大把的时间慢慢给 bootloader 加东西就好了，能用 C 就不要用汇编。开发中的很多细节要到开发时才留意的到，这时可以自己思考，也可以去抄 linux 0.11, xv6, unixv6 这几套优秀的源码。

现在想来，开发一个 kernel 的主要内容在于“实现”而不是“设计”，更重要的是用时间去理解这些优秀的设计为什么合理，自己别出心裁的想法一般不用多想，一定是错的。

不要在 x86 的一些历史遗留问题上花太多时间，比如 bootloader 的保护模式会在开头挡住一大批人，可是这并不重要，只要知道有这个接口可以引导你的二进制代码即可。知道 GDT 可以区分用户态/内核态，IDT 可以给中断绑回调就行了。在调试上会花费大量时间，可以慢慢琢磨怎样提高调试的效率。然后需要的就只是耐性了，说实话也挺无聊。



自身版：
1c语言要求：我自己在大学里几乎没学过c语言，上机几乎10道题会2道，期末全靠背。后来开始自学了c，看了c语言程序设计现代方法，c和指针 c专家编程 第一本书的课后题，做了3分之2吧，就这样，没了
2汇编要求：会基本的x86指令，仅仅是基本，看了王爽的汇编语言，程序写的很少，仅仅上机课写过，不过能很快写出来。
3微机原理或者计算机组成原理：老师上课太坑了实在，我自己看了csapp的前四章大概，豁然开朗，推荐这个。
4操作系统：看了三个礼拜os的基本概念，仅仅是了解概念，没办法深入，也没地方。。。。
5数据结构：看过浙大的数据结构公开课的3分之2，会写基本的链表，队列，最基本的树和树的基本的遍历办法，图完全不会
6单片机基础：大约两年的单片机基础
7新手看到这里，可能已经慌乱了。。。。不要怕，我说的很多东西，写嵌入式系统用不到啊 ，继续，发一个精简版

精简版
1:c语言 能把我推荐的c书的第一本或者c primer之类的书看个一半，或者自己本身知道指针的概念，知道结构体指针，函数指针，二级指针的用法，仅仅是概念和写法就行了，不用深入，用不了多久。
2汇编：知道有几条常用指令，用法和功能是什么就可以了
3组成原理：知道中断是什么，入栈和出，寄存器，知道汇编对应的计算机大概动作就可以了，用不了一个周
4操作系统:找个公开课或者书，看看大概的os概念，一个周就够了，我现在很多概念还是不知道，后面可以慢慢学
5数据结构：会写链表，队列就行了，我们不写文件系统，不用树
6单片机基础：用过单片机，不用自己写驱动代码，仅仅可以在别人的驱动下，编写一些简单的逻辑代码就行，完全没学过的人，两个礼拜就可以用stm32来编程了，如果之前学过51，一个礼拜不到即可，因为我们只是借助一下单片机，避免使用虚拟机，方便操作系统的调试。因为我们可以用单片机，输出某些信息在串口或者液晶屏，让我们直接看到代码的错误点，方便我们调试。

因为很多大一的新生想写，推出一个极限版~~
极限版
1.学过C，知道有指针这个东西，其他的边做边学。
2.不懂汇编，边做边查，边查边写。
3.知道什么是寄存器，知道中断的概念
4.知道OS是由什么组成的
5.数据结构完全不会，遇到链表，队列时再查，或者直接抄也行
6.不学如何使用单片机，遇到再查









大二的时候，老师（中山大学万海）对我们说：“如果有谁能自己写一个内核出来，那么，他平时可以不来听课，也不用做平时作业，做出来还能加分，怎么样，有没有人有兴趣？”

和老师一番讨价还价之后，我成为全年级几百号人里唯一一个自己写内核/整个学期都不去教室听课/任何作业都不做的那个人（代表着我的身边将没有可以提供参考的人，任何资料都只能自己找）。

一开始买了《30天自制操作系统》，上面写着需要软盘还有其它的模拟器，我的初衷是写一个可以烧在真机上一按开机键就能跑起来的那种，所以看了几页后就丢开了。后来又找了国人写的一本，也不是特别符合，也丢开了。

这时我看到了那本教材（俗称绿宝书），约莫800页。之后的两个星期里，我每天泡图书馆，以每小时10页的速度读完了它，在上面乱涂乱画了许多标记。800页的英文书，我从中学到了大量的基本概念（线程进程，内存算法，寻址方式等等）。

接着我寻思直接从网络上而不是从书上寻找资料，TA师兄给我提供了一个OS Development，我照着上边的例子，写了数以千记的汇编代码，习得了汇编技能。

此时，我具备基本的概念知识，对程序的语言也已经理解，知道了虚拟机的调试方法，差的，就只有对内核整体是如何协作不太明白。于是我去找来老师用于教学的PintOS，找来MIT那个项目的代码，还有国内一个高校自制的OS（是几个研究生一起写的），仔细研究了一遍，最后开始写代码。

在那个学期里，我放弃了LOL，一心看代码，写内核，写各种模块，将过程记录在博客上，花了三个月的时间，最终写出一个具备terminal的内核（文件系统没写好，时间不够），可以跑命令，运行函数，管理内存和进程，处理中断。






如果你想知道具体整个编写的过程是怎样的，可以看看我当时的记录，如下（很长）：

原文:(http://www.ilovecl.com/2015/09/15/os_redleaf/ )





叔的答案，然后看了 F 叔给的这个链接 基于 Bochs 的操作系统内核实现 ，当然是什么都看不懂，除了惊诧之外也了解了一件事情：一个人写一个简单的操作系统内核是一件非常帅气并且可行的事情。

于是我开始写了，那时候我的水平大概是：只会做 C 语言的习题，编译的话只知道按 F9，汇编知道常见的指令，另外会一点点的 Win 32 编程，能流畅使用 Windows。

一开始我找了《30 天自制操作系统》来看，每天看书，然后把从书里把代码打出来，一次一次地编译运行。因为要同时写汇编和 C，所以从那时候起就开始用 vim。

在啃完了差不多半本书后，开始觉得没意思了……因为觉得作者为了让内容更简单而省略了太多细节。也看了于渊的《Orange‘s 一个操作系统的诞生》，依然没看下去：汇编用得太多了。期间也曾斗胆发邮件给 F叔，然后他推荐了 Bran's Kernel Development Tutorial 这个教程，于是我就从这教程重新开始了： 「30天自制操作系统」 Stop & 「OS67 」 Start

那时候大概是大二上学期，于是在 github 上又开了一个 repo，一开始在 Windows 下开发，后来又切换到了 Linux 下，因为 Bran's 用的 bootloader 是 Grub，不符合我的初衷，所以就自己写了一个，之后便跟一路教程写，跨过了保护模式这道坎，完成了基本的设备驱动。

在完成 Bran's 后，我又部分参考了 写一个操作系统内核有多难？大概的内容、步骤是什么？ - To浅墨的回答 中推荐的：hurley25/hurlex-doc · GitHub 文档，完成了一些简单的调试函数和库函数，printk 和内存分配。
事实证明，尽早写好调试函数诸如 panic， assert 和 printk 是非常重要的。 大量地使用有助于你尽快地发现 bug （当然前提是这些函数本身不能有 bug）。

看完了 hurlex-doc 该看的部分后，很长一段时间了都不知道该干嘛好，模仿 hurlex-doc 里的内核线程切换也一直出错。这一情况一直持续到我开始读 Xv6, a simple Unix-like teaching operating system 。

如果你去看知乎关于「自制内核」的问题，你会发现 xv6 被反复地提及并推荐，事实上它非常值得被推荐：这是我读完大部分代码之后真切体会到的。

之前的 Bran‘s 和 hurlex-doc 的篇幅都比较小，我是在电脑和 kindle 上看完的，xv6 相对来说代码量比较大，有 9000+ 行和一份文档，之后我又找到了这个：ranxian/xv6-chinese · GitHub xv6 文档的中文译版，所以我就去花了十二块钱学校打印店打印了一份中文文档和一份代码。这又是一个正确的决定，让我不必对着电脑就能看代码。

在之后的时间里，我先读了 xv6 中文件系统相关的部分，然后改写它的代码为我的内核添加了一个 类似 Minix 的文件系统。 然后几乎又照抄了其中了进程调度的部分（做了部分简化），又在原来的代码基础上为添加操作系统的接口，接着写用户程序，过程几乎是「一路顺风」。看 xv6 的那段时间也经常是处于醍醐灌顶的状态。

最后我终于在差不多一个月前完成了这个简陋的操作系统内核：
LastAvenger/OS67 · GitHub （没错其实我是来骗 star 的）

历时一年，一路点亮了不少技能树（虽然都点得不好），这样算是「从零开始写一个简单的操作系统」么？ 跟进一步说，有谁不是从零开始的呢？ 所以想做的话，现在就开始做好了。








